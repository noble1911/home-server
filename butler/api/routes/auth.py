"""Authentication routes: invite code redemption, token refresh, and LiveKit tokens.

POST /api/auth/redeem-invite — PWA sends invite code, gets JWT tokens
POST /api/auth/refresh       — Exchange refresh token for new token pair
POST /api/auth/token         — Authenticated user gets a LiveKit room token
"""

from __future__ import annotations

import uuid

import jwt as pyjwt
from fastapi import APIRouter, Depends, HTTPException

from tools import DatabasePool

from ..auth import (
    create_livekit_token,
    create_user_tokens,
    decode_refresh_jwt,
    hash_token,
)
from ..config import settings
from ..deps import get_current_user, get_db_pool
from ..models import (
    AuthTokens,
    LiveKitTokenResponse,
    RedeemInviteRequest,
    RedeemInviteResponse,
    RefreshTokenRequest,
)

router = APIRouter()


async def _store_refresh_token(db, token: str, user_id: str) -> None:
    """Hash and store a refresh token in the database."""
    await db.execute(
        """INSERT INTO butler.refresh_tokens (token_hash, user_id, expires_at)
           VALUES ($1, $2, NOW() + make_interval(hours => $3))""",
        hash_token(token),
        user_id,
        settings.jwt_refresh_expire_hours,
    )


@router.post("/redeem-invite", response_model=RedeemInviteResponse)
async def redeem_invite(
    req: RedeemInviteRequest,
    pool: DatabasePool = Depends(get_db_pool),
):
    """Validate invite code, create or find user, and return JWT tokens.

    Two paths:
    - Bootstrap: If no real users exist, accept the env-var code and
      create the first user as admin.
    - Normal: Validate against the butler.invite_codes table (DB-managed,
      single-use, expiring codes generated by an admin).
    """
    db = pool.pool
    code_upper = req.code.strip().upper()

    # Check if any real users exist (exclude seed users)
    user_count = await db.fetchval(
        "SELECT COUNT(*) FROM butler.users WHERE id NOT IN ('default', 'system')"
    )

    if user_count == 0:
        # --- BOOTSTRAP: First user becomes admin ---
        valid_codes = [c.strip().upper() for c in settings.invite_codes.split(",")]
        if code_upper not in valid_codes:
            raise HTTPException(401, "Invalid invite code")

        user_id = f"invite_{code_upper.lower().replace('-', '_')}"
        await db.execute(
            "INSERT INTO butler.users (id, name, role) VALUES ($1, $1, 'admin') "
            "ON CONFLICT (id) DO UPDATE SET role = 'admin'",
            user_id,
        )
        role = "admin"
    else:
        # --- NORMAL: Validate against DB invite_codes table ---
        invite = await db.fetchrow(
            """SELECT code FROM butler.invite_codes
               WHERE code = $1 AND used_by IS NULL AND expires_at > NOW()""",
            code_upper,
        )
        if not invite:
            # Code wasn't a valid unused DB code — check fallback paths:
            # 1. Env-var codes (admin re-login)
            # 2. Already-used DB codes (user re-login after refresh token expiry)
            user_id = f"invite_{code_upper.lower().replace('-', '_')}"
            user = None

            valid_codes = [c.strip().upper() for c in settings.invite_codes.split(",")]
            if code_upper in valid_codes:
                # Env-var code — allow existing users to re-authenticate
                user = await db.fetchrow(
                    "SELECT id, role FROM butler.users WHERE id = $1", user_id
                )

            if not user:
                # Check if this is a used DB code — allow the same user back in
                used_invite = await db.fetchrow(
                    """SELECT used_by FROM butler.invite_codes
                       WHERE code = $1 AND used_by IS NOT NULL""",
                    code_upper,
                )
                if used_invite:
                    user = await db.fetchrow(
                        "SELECT id, role FROM butler.users WHERE id = $1",
                        used_invite["used_by"],
                    )
                    if user:
                        user_id = user["id"]

            if user:
                role = user["role"]
            else:
                raise HTTPException(401, "Invalid or expired invite code")
        else:
            # New user from DB invite code
            user_id = f"invite_{code_upper.lower().replace('-', '_')}"
            existing = await db.fetchrow(
                "SELECT id, role FROM butler.users WHERE id = $1", user_id
            )
            if existing:
                role = existing["role"]
            else:
                await db.execute(
                    "INSERT INTO butler.users (id, name, role) VALUES ($1, $1, 'user')",
                    user_id,
                )
                role = "user"

            # Mark the invite code as used
            await db.execute(
                "UPDATE butler.invite_codes SET used_by = $1, used_at = NOW() WHERE code = $2",
                user_id,
                code_upper,
            )

    # Check onboarding status
    user = await db.fetchrow(
        "SELECT name FROM butler.users WHERE id = $1", user_id
    )
    has_onboarded = user is not None and user["name"] != user_id

    # Issue tokens
    access_token, refresh_token, expires_at = create_user_tokens(user_id, role)
    await _store_refresh_token(db, refresh_token, user_id)

    return RedeemInviteResponse(
        tokens=AuthTokens(
            accessToken=access_token,
            refreshToken=refresh_token,
            expiresAt=expires_at,
        ),
        hasCompletedOnboarding=has_onboarded,
        role=role,
    )


@router.post("/refresh", response_model=RedeemInviteResponse)
async def refresh_tokens(
    req: RefreshTokenRequest,
    pool: DatabasePool = Depends(get_db_pool),
):
    """Exchange a valid refresh token for new access + refresh tokens.

    Implements refresh token rotation: the old refresh token is revoked
    and a new pair is issued. This limits the damage window if a refresh
    token is compromised.
    """
    try:
        payload = decode_refresh_jwt(req.refreshToken)
    except pyjwt.InvalidTokenError:
        raise HTTPException(401, "Invalid refresh token")

    user_id = payload["sub"]
    token_hash = hash_token(req.refreshToken)
    db = pool.pool

    # Verify token exists in DB, is not revoked, and not expired
    stored = await db.fetchrow(
        """SELECT id FROM butler.refresh_tokens
           WHERE token_hash = $1 AND user_id = $2
             AND revoked_at IS NULL AND expires_at > NOW()""",
        token_hash,
        user_id,
    )
    if not stored:
        raise HTTPException(401, "Refresh token revoked or expired")

    # Revoke old refresh token (rotation)
    await db.execute(
        "UPDATE butler.refresh_tokens SET revoked_at = NOW() WHERE token_hash = $1",
        token_hash,
    )

    # Get current role from DB (not from stale token)
    user = await db.fetchrow(
        "SELECT name, role FROM butler.users WHERE id = $1", user_id
    )
    if not user:
        raise HTTPException(401, "User not found")

    role = user["role"]
    has_onboarded = user["name"] != user_id

    # Issue new token pair
    access_token, new_refresh, expires_at = create_user_tokens(user_id, role)
    await _store_refresh_token(db, new_refresh, user_id)

    return RedeemInviteResponse(
        tokens=AuthTokens(
            accessToken=access_token,
            refreshToken=new_refresh,
            expiresAt=expires_at,
        ),
        hasCompletedOnboarding=has_onboarded,
        role=role,
    )


@router.post("/token", response_model=LiveKitTokenResponse)
async def get_livekit_token(
    user_id: str = Depends(get_current_user),
):
    """Generate a LiveKit room token for the authenticated user.

    Each voice session gets a unique room so a fresh agent is always
    dispatched. Without this, reconnecting to the same static room
    reuses a dead agent session (close_on_disconnect kills it).
    """
    session_suffix = uuid.uuid4().hex[:8]
    room_name = f"butler_{user_id}_{session_suffix}"
    token = create_livekit_token(user_id, room_name)
    return LiveKitTokenResponse(livekit_token=token, room_name=room_name)
